

# python_test

Python's test repository
引用サイト:[python-izm](https://www.python-izm.com)

[TOC]



# 基礎編

- [x] 文字列

- [x] 数値

- [x] 日付・時間

- [x] 配列・連想配列

- [x] タプル

- [x] リスト

- [x] ディクショナリ 

- [x] セット

- [x] スライス

- [x] コメントアウト

- [x] インポート

- [x] コマンドライン引数

- [x] エスケープシーケンス

- [x] パスの結合・連結

- [x] if文

- [x] for文

- [x] while文

- [x] break

- [x] continue

- [x] rangeとxrange

- [x] print

- [x] 例外処理


### タプル

要素の追加削除ができない
()で要素を囲む

### リスト

要素の追加削除が可能
[]で要素を囲む

+ 変数.append(引数)
  先頭の空の要素から追加する

+ 変数.insert(引数,引数)
  第一引数で追加インデックス値を、第二引数で追加要素を指定

+ 変数.remove(引数) 
  引数に該当する最初に該当した要素を削除

+ 変数.pop(引数)
  引数のインデックス値の値を取り出す（戻り値として返す）。引数なしだと要素の末尾を取り出す

+ 変数.index(引数)
  引数に該当するインデックス値を取得。remoceと同様に最初に該当したインデックス値を取得

### ディクショナリ

keyとvalueのセット
{}で要素を囲む

+ 変数.get(第一引数,第二引数)
  引数でkeyを指定し、要素を取得。keyがない場合、noneと表示
  第二引数を入れた場合、noneの表示を変更できる
+ 変数[key] = "要素"
  keyを指定し、要素の追加を行う

+ del 変数[key]
  引数に削除するkeyを指定

+ 変数.keys() もしくは 変数.values()
  keyもしくはvalueを取得

+ for key, value in 変数.items(): print(key,value)
  keyとvalueを同時取得

+ key in 変数
  指定したkeyを取得しているかを確認(T/F)



# 応用編



- [x] 関数・メソッド
- [x] 可変長引数
- [x] クラス作成
- [x] クラス継承
- [x] 新旧クラススタイル
- [x] 親クラスのメソッド呼び出し
- [x] メソッドの種類
- [x] インスタンスメソッド
- [x] クラスメソッド
- [x] スタティックメソッド
- [ ] モジュールのパッケージ化
- [ ] lambda式
- [ ] ジェネレータ
- [ ] ファイル読み書き
- [ ] ファイルシステム操作
- [ ] with文
- [ ] コンテキストマネージャ
- [ ] プロパティ
- [ ] 設定ファイル
- [ ] リストのソート
- [ ] リストの逆順
- [ ] インデックスつきループ
- [ ] 要素を区切り文字で連結
- [ ] 複数のリストを同時に処理
- [ ] 要素の一括審議判定
- [ ] 順序保持ディクショナリ(2.7~3.6)
- [ ] セットの比較・作成・更新
- [ ] 内包表記
- [ ] 変数の型チェック
- [ ] 属性の有無チェック
- [ ] 呼び出し可能チェック
- [ ] 最小値・最大値の取得
- [ ] 合計値の取得
- [ ] モジュールの属性取得
- [ ] セパレータの取得
- [ ] ファイル拡張子の取得
- [ ] 改行コードの取得
- [ ] 環境変数の取得
- [ ] 乱数値の取得
- [ ] zip圧縮
- [ ] csvファイルの読み書き
- [ ] ハッシュ化
- [ ] UUID生成
- [ ] メール送信
- [ ] HTML解析
- [ ] XML解析
- [ ] JSON変換
- [ ] マルチスレッド
- [ ] XML-RPC

### format関数

文字列内に変数を埋め込むことができる

利点としては、文字列ないで動的に変わる変数を利用することができる。

```python
"任意の文字列{}任意の文字列".format(変数)
```

記述例)

```python
val1 = コーヒー
val2 = ミルク
val3 = 紅茶
print("{0}では{1}と{2}と{3}を注文した".format("カフェ",val1,val2,val3))
```

## クラス

今までに使用してきたint型やstr型といった整数や文字列を扱う特定の型に属するオブジェクトを使用してきた。今までに使用してきたこれらの型を独自に作り出すのがクラスである。

ここでいうオブジェクトは「プログラムの実行時に作成されて、コンピュータのメモリ上に存在する何かしらのデータ」のことである。これに対して、クラスは「オブジェクトを作成するための設計図」といえる。オブジェクトがどんな値を持ち、どんなメソッドを持ち、どんな演算が可能かを詳細に記したものがクラスである。

オブジェクトは「あるクラスの設計図から作り出され、メモリ上に存在する実体」であることを強調するために「インスタンス」と呼ぶこともある。

### クラスの定義

```python
class クラス名:
  クラス定義の本体(クラスが持つ属性を定義する)
```

クラス名についてはコーディングスタイルガイドより、「単語の先頭は大文字で初めて、複数の単語で綴られるときは、それらを_なdのを使わずにつなげる」ものとすること。

作成例)

```python
class Point:
  pass
```

### クラスからインスタンスを生成する

作成したクラスを以下のコードで実行してみる

```python
point1 = Point()
print(type(point1))
```

```bash
<class '__main__.Point'>
```

出力結果にはpythonの対話環境を利用している場合にコードを実行する環境になっている__main__環境が表示されている

### objectクラス

クラスには定義するだけで、pythonのオブジェクトが持つ基本的な機能が備わるようになっている。以下のコードで確認する

```python
print(dir(point1))
```

```bash
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__']
```

Pointクラスの定義はpass文しかないのに、アンダースコアで始まるいくつもの属性が表示された。これらはpythonの「すべてのオブジェクトの基盤」のobjectクラスから来ている。このため上記のクラス定義の構文は実際には以下のコードを省略した表記となっている。

```python
class Point(object):
  pass
```

クラスは何かのクラスを基に新しく作成できるが、その時には「クラス名」に続けて()の中に「基となるクラス」を列挙していく（これを省略するとobjectクラスを基にしたクラスが生成される）。

このように、特定のクラスを基にして、新しくクラスを定義することを「継承」と呼ぶ。継承を使うことでよく似た特性を持つ、しかし細部が異なるデータを表すクラスを効率的に定義できるようになる。

### クラスやインスタンスの属性

Pointクラスが座標を扱うクラスとして作成する場合以下の2つが必要となってくる

+ X座標を表す値
+ Y座標を表す値

これら2つは、値を保存しておくのでPointクラスの個々のインスタンスが持つ変数のようなものである。このことからこれらを「インスタンス変数」と呼ぶ。

また、これ以外に次のような処理が可能であると望ましい。

+ 原点からの距離を調べる
+ 他の座標との距離を調べる

これらはインスタンスが持つ個々の値を利用して計算処理を行うので「インスタンスメソッド」と呼ぶ。

座標を表すデータにはこれらの変数やメソッドを持つことを、設計図としてPythonのコードを使って記述したものがPointクラスの定義であり、それを基にした具体的なX座標やY座標の値を持ったものがPointクラスのインスタンスとなる。

### インスタンス変数

Pointクラスのインスタンスに属性x/yに値を代入

```python
point1.x = 1.0
point1.y = 1.0
```

これでPointクラスの属性を確認するとx,y属性が追加されている。

ここで新しくPoint2クラスを作成しx,yの値を設定できるようにする。

### __init__メソッド

メソッドとはあるクラスに固有の処理を実行するために使われる関数のことであり、クラス定義の中でdef文を使って関数を定義することでそれがメソッドとして扱われるようになる。__init__メソッドは荘子たメソッドの1つだが、Pythonでは特殊な扱いをされていて、インスタンスが生成される際に、そのインスタンスごとに固有の初期化処理を行うため、このメソッドが自動的に呼び出されるようになっている。

```python
def __init__(self[, param]):
  インスタンスの初期化処理を行うコード
```

selfが示すオブジェクトの初期化を行う。初期化の際に何らかのデータが必要であればパラメータを介して、それらを受け渡せる。

|パラメータ|説明|
|-|-|
|self|初期化を行うインスタンス|
|param|初期化に必要なデータを列挙する|

class定義の本文の中で、def文により関数を定義すると、それらはそのクラスのメソッドとなる。通常の関数とは異なり、その第１パラメータは常に「self」となる。__init__メソッドの場合、パラメータselfはその内部で初期化処理を行う対象となるインスタンスを示す。通常のメソッドは「インスタンス.メソッド(引数)」の形で呼び出すが、このとき「インスタンス」が自動的にselfと代入されるため、メソッド呼び出しでself自体を明示する必要がない。

第二パラメータ以降にはインスタンス初期化に必要となる者を列挙していく。例えば、ここではX座標の値とY座標の値が必要となる。値はクラス名()の関数呼び出しの際に指定したものが__init__メソッドに渡されるようになっている。よって、「point1 = Point(1.0,1.0)」のようにすれば2つの浮動少数点数値が__init__メソッドに渡される。

作成例)

```python
class Point:
  def __init__(self, x=0.0, y=0.0):
    self.x = x
    self.y = y
```

以上に記述した新しいPointクラスでインスタンスpoint1とpoint2を作成する。

```python
point1 = Point(1.0,1.0)
point2 = Point()
print(f"point1: ({point1.x}, {point1.y})")
print(f"point2: ({point2.x}, {point2.y})")
```

ここではpoint1インスタンス生成ではPoint(1.0,1.0)としているので、その属性であるx,yは1.0で初期化される。一方point2インスタンス生成では引数を省略しているので、その属性であるx,yは共に0.0で初期化される。

### インスタンスメソッド

最後に以下の2つの処理を行うメソッドを定義する。

+ 原点からの距離を調べる
+ 他の座標との距離を調べる

二つの座標の距離は次の式で求められる。

$$
\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}
$$

よって以下のコードによってインスタンスメソッドは定義できる。

```python
from math import sqrt

class Point:
  def __init__(self,x=0.0,y=0.0):
    self.x = x
    self.y = y
  def difference(self, point=None):
    if not point:
      point = Point() #原点を表すPointクラスインスタンスを生成
     return sqrt((self.x - point.x)**2 + (self.y - point.y)**2)
```

__init__と同様に第一パラメータはselfになる。point1.difference(何かの値)のようにして、メソッドを呼び出した時には、selfにはpoint1オブジェクトが代入される。

第二パラメータにはPointクラスのインスタンスを渡すが、そのデフォルト引数値に「None」が指定されている、よって、differenceメソッドで引数を指定しなかった時には、パラメータpointの値はNoneになる。

ここでパラメータpointがNone（False）かどうかをif文で調べ、そうである場合原点を表すPointクラスオブジェクトを生成している。これによって、原点からの距離を導出することができる。

最終的なコードを以下に示す。

```python
from math import sqrt

class Point:
  def __init__(self, x=0.0, y=0.0):
    self.x = x
    self.y = y
  def difference(self, point=None): 
    if not point:
      point = Point()
    return sqrt((self.x - point.x)**2 + (self.y -point.y)**2)
    
point1 = Point(1.0,1.0)
point2 = Point()
point3 = Point(5,4)

print(point1.difference(point2))
print(point1.difference())
print(pint3.difference(point1))
```



# 参考サイト

[クラスの基礎知識](https://www.atmarkit.co.jp/ait/articles/1907/26/news020.html)

